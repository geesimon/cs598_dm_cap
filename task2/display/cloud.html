<!DOCTYPE html>
<meta charset="utf-8">
<body>
    <script src="d3.v3.min.js"></script>
    <script src="d3.layout.cloud.js"></script>
    <script>
    // Encapsulate the word cloud functionality
    function wordCloud(selector) {

        var fill = d3.scale.category20();

        //Construct the word cloud's SVG element
        var svg = d3.select(selector).append("svg")
            .attr("width", 500)
            .attr("height", 500)
            .append("g")
            .attr("transform", "translate(250,250)");


        //Draw the word cloud
        function draw(words) {
            var cloud = svg.selectAll("g text")
                            .data(words, function(d) { return d.text; })

            //Entering words
            cloud.enter()
                .append("text")
                .style("font-family", "Impact")
                .style("fill", function(d, i) { return fill(i); })
                .attr("text-anchor", "middle")
                .attr('font-size', 1)
                .text(function(d) { return d.text; })
                .on("click", clickword);

            //Entering and existing words
            cloud
                .transition()
                    .duration(600)
                    .style("font-size", function(d) { return d.size + "px"; })
                    .attr("transform", function(d) {
                        return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                    })
                    .style("fill-opacity", 1);

            //Exiting words
            cloud.exit()
                .transition()
                    .duration(200)
                    .style('fill-opacity', 1e-6)
                    .attr('font-size', 1)
                    .remove();
        }


        //Use the module pattern to encapsulate the visualisation code. We'll
        // expose only the parts that need to be public.
        return {

            //Recompute the word cloud for a new set of words. This method will
            // asycnhronously call draw when the layout has been computed.
            //The outside world will need to call this function, so make it part
            // of the wordCloud return value.
            update: function(words) {
                d3.layout.cloud().size([500, 500])
                    .words(words)
                    .padding(2)
                    //.rotate(function() { return ~~(Math.random() * 2) * 90; })
                    .rotate(function() { return (~~(Math.random() * 6) - 3) * 30; })
                    .font("Impact")
                    .fontSize(function(d) { return d.size; })
                    .on("end", draw)
                    .start();
            }
        }

}


//This method tells the word cloud to redraw with a new set of words.
//In reality the new words would probably come from a server request,
// user input or some other source.
function showNewWords(vis, words, values) {
    //i = i || 0;
    //vis.update(getWords(i ++ % words.length))
    //setTimeout(function() { showNewWords(vis, i + 1)}, 2000)
    vis.update(words.map(function(d, i) {
                return {text: d, size: 10 + values[i] * 50};
            }))
}

//Create a new instance of the word cloud visualisation.
var myWordCloud = wordCloud('body');
var nodes;

const urlParams = new URLSearchParams(window.location.search);
const data_file = urlParams.get('data');

d3.json(data_file, function(miserables) {
    nodes = miserables.nodes;

    // Compute index per node.
    nodes.forEach(function(node, i) {
        node.index = i;
        node.count = 0;
        node.link_words = [];
        node.link_values = []
    });
    
    // Compute index per node.
    nodes.forEach(function(node, i) {
        node.index = i;
        node.count = 0;
        node.link_words = [];
        node.link_values = []
    });
    miserables.links.forEach(function(link) {
        nodes[link.source].count += link.value;
        nodes[link.target].count += link.value;

        nodes[link.source].link_words.push(nodes[link.target].name);
        nodes[link.source].link_values.push(link.value);
        nodes[link.target].link_words.push(nodes[link.source].name);
        nodes[link.target].link_values.push(link.value);
    });

    //Start cycling through the demo data
    showNewWords(myWordCloud, nodes[0].link_words, nodes[0].link_values);
})

function clickword (p) {
    var index = -1;
    nodes.forEach(function(node, i){
        if (node.name == p.text) {
            index = i;
            return;
        }
    })
     
    showNewWords(myWordCloud, nodes[index].link_words, nodes[index].link_values);
}
</script>